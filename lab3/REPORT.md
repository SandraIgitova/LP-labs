#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Семенов И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

## Введение

Очевидно, по каким причинам Prolog хорошо подходит для решения простых логических задач, но что насчет более сложных? Некоторые задачи можно представить в виде пары из множества некоторых доступных состояний и множества переходов между этими состояниями(то есть, в виде графа состояний). Для решения задач, представимых в таком виде, решением является путь в графе от начальной вершины до конечной. Основными стратегиями решения являются алгоритмы поиска в графах - поиск в глубину, поиск в ширину и поиск с итерационным заглублением. Вышеописанные задачи также называют задачами на поиск в пространстве состояний.

В языке Prolog удобнее всего описывать граф предикатами, с помощью явного перечисления всех дуг в виде пар вершин. Такие дуги можно задавать не только явным перечислением, но и с помощью некоторых правил, что делает возможным описание достаточно больших и сложных графов.

## Задание

5. Вдоль доски расположены лунки, в каждой из которых лежит черный или белый шар. Одним ходом можно менять местами два соседних шара. Добиться того, чтобы сначала шли белые шары, а за ними - черные. Решить задачу за наименьшее число ходов.

## Принцип решения

Представим каждое состояние в виде структурного терма state(), внутри которого находится пара списков. В первом списке перечислены цвета шаров, находящихся слева от свободной лунки, во втором цвета оставшихся шаров. Далее используем поиск в глубину(как наиболее подходящий для решения данной задачи) для нахождения решения.

Вспомогательный предикат для вставки и удаления из произвольной позиции в списке.

remove_index([X|T], T, X, 1).
remove_index([X|T], NewList, RemovedElement, Index) :-
    Index \= 1,
    NewIndex is Index - 1,
    remove_index(T, List, RemovedElement, NewIndex),
    NewList = [X|List].

remove_last([X|T], L, E) :- 
    length([X|T], Length),
    remove_index([X|T], L, E, Length).

    


Предикат, позволяющий получить возможные переходы из переданного состояния

next_state(state(LList, RList), state(NewLList, NewRList)) :- 
    length(LList, LLength),
    remove_index(LList, NewLList, X, LLength),
    NewRList = [X|RList].

next_state(state(LList, RList), state(NewLList, NewRList)) :- 
    RList = [X|NewRList],
    append(LList, [X], NewLList).
    
next_state(state(LList, RList), state(NewLList, NewRList)) :- 
    remove_last(LList, Temp, Last),
    remove_last(Temp, NewLList, PreLast),
    NewRList = [Last, PreLast|RList].

next_state(state(LList, RList), state(NewLList, NewRList)) :- 
    RList = [First, Second|NewRList],
    append(LList, [Second, First], NewLList).

Предикат для вывода результата.

print_result([]).
print_result([state(X,Y)|T]) :-
    write(X), write("  "), write(Y), nl,
    print_result(T).

Основной предикат и поиск в глубину.

solve() :-
    dfs([state([b,b,b], [w,w,w])], state([w,w,w], [b,b,b]), List),
    reverse(List, Result),
    print_result(Result),
    not(check_result(Result)).

prolong([X|T], [Y, X|T]) :-
    next_state(X, Y), not(member(Y, [X|T])).

dfs([X|T], X, [X|T]).

dfs(P,F,L) :-
    prolong(P, P1), dfs(P1, F, L).

## Результаты

?- solve
[b,b,b]  [w,w,w]
[b,b]  [b,w,w,w]
[b,b,w,b]  [w,w]
[b,b,w]  [b,w,w]
[b,b]  [w,b,w,w]
[b]  [b,w,b,w,w]
[b,w,b]  [b,w,w]
[b,w]  [b,b,w,w]
[b]  [w,b,b,w,w]
[]  [b,w,b,b,w,w]
[w,b]  [b,b,w,w]
[w]  [b,b,b,w,w]
[w,b,b]  [b,w,w]
[w,b,b,b]  [w,w]
[w,b,b,b,w]  [w]
[w,b,b]  [w,b,w]
[w,b]  [b,w,b,w]
[w]  [b,b,w,b,w]
[]  [w,b,b,w,b,w]
[b,w]  [b,w,b,w]
[b]  [w,b,w,b,w]
[b,b,w]  [w,b,w]
[b,b]  [w,w,b,w]
[b]  [b,w,w,b,w]
[b,w,b]  [w,b,w]
[b,w,b,w]  [b,w]
[b,w,b,w,b]  [w]
[b,w,b,w,b,w]  []
[b,w,b,w]  [w,b]
[b,w,b]  [w,w,b]
[b,w]  [b,w,w,b]
[b]  [w,b,w,w,b]
[]  [b,w,b,w,w,b]
[w,b]  [b,w,w,b]
[w]  [b,b,w,w,b]
[w,b,b]  [w,w,b]
[w,b,b,w]  [w,b]
[w,b,b,w,w]  [b]
[w,b,b,w,w,b]  []
[w,b,b,w]  [b,w]
[w,b]  [w,b,b,w]
[w]  [b,w,b,b,w]
[]  [w,b,w,b,b,w]
[b,w]  [w,b,b,w]
[b]  [w,w,b,b,w]
[b,w,w]  [b,b,w]
[b,w,w,b]  [b,w]
[b,w,w,b,b]  [w]
[b,w,w,b,b,w]  []
[b,w,w,b]  [w,b]
[b,w,w]  [b,w,b]
[b,w]  [w,b,w,b]
[b]  [w,w,b,w,b]
[]  [b,w,w,b,w,b]
[w,b]  [w,b,w,b]
[w]  [b,w,b,w,b]
[w,w,b]  [b,w,b]
[w,w]  [b,b,w,b]
[w]  [w,b,b,w,b]
[w,b,w]  [b,w,b]
[w,b,w,b]  [w,b]
[w,b,w,b,w]  [b]
[w,b,w,b,w,b]  []
[w,b,w,b]  [b,w]
[w,b,w]  [b,b,w]
[w]  [w,b,b,b,w]
[]  [w,w,b,b,b,w]
[w,w]  [b,b,b,w]
[w,w,b]  [b,b,w]
[w,w,b,b]  [b,w]
[w,w,b,b,b]  [w]
[w,w,b,b,b,w]  []
[w,w,b,b]  [w,b]
[w,w,b,b,w]  [b]
[w,w,b]  [w,b,b]
[w,w]  [b,w,b,b]
[w,w,w,b]  [b,b]
[w,w,w]  [b,b,b]
time:0.025386571884155273
true

Ввиду большого количества возможных переходов, не представляется возможным использовать поиск в ширину или ID поиск.


## Выводы

В результате данной лабораторной работы, я узнал много нового об алгоритмах поиска в графах и об их реализациях в языке  Prolog.
 
Благодаря лаконичности Prolog, алгоритмы поиска реализуются на нем гораздо проще, чем на императивных языках. Я научился реализовывать все алгоритмы поиска в графах, но поиск в ширину и поиск с итерационным заглублением не подходили для решения задачи и поэтому были удалены из программы.

Также я узнал об особенностях этих алгоритмов - поиск в глубину хорош в условиях ограниченной памяти, поиск в ширину позволяет найти кратчайший путь, а поиск с итерационным заглублением сочетает в себе некоторые их преимущества и недостатки.



