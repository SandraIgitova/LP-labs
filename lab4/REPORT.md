#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Семенов И.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие подходы обычно применяются для обработки естественных и искусственных языков?
Почему Prolog оказывается удобным языком для решения таких задач?

Обработка языка - нетривиальная задача, которая не решена в общем случае до сих пор. Основная трудность этой задачи состоит не только в том, что необходимо научить машину "понимать" текст, но и в том, что интерпретируя некоторый текст, мы опираемся на "общечеловеческие" знания, которые также нужно как то формализовать.

Несмотря на это, более частные задачи решатся довольно успешно. Решение задачи разбора языка в первую очередь зависит от свойств этого языка(от того, к какому классу относится его грамматика).

Регулярные грамматики легко обрабатывать с помощью конечных автоматов(являющихся детерминированными), поэтому анализ таких языков легко реализуется на императивных языках программирования. 

Контекстно зависимы и контекстно свободные грамматики же таким образом обработать не так просто. В процессе разбора может появляться множество возможных вариантов, а с перебором и отбрасыванием неподходящих вариантов отлично справляются языки логического программирования.

## Задание

1. Генеалогическое дерево задано фактами вида
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).

Написать программу на Прологе, запросы к который будут выглядеть следующим образом.

Запросы:
?- answer([volodia,brat,toli,'?'],X).
?- answer([kto,tolin,brat,'?'],X).
?- answer([chei,brat,volodia,'?'],X).
Результаты:
X=yes, X=volodia, X=tolia


## Принцип решения

Программа разбирает переданное ей предложение и строит небольшое синтаксическое дерево, которое потом обрабатывает, выводя ответ.

Предикаты, представляющие генеалогическое дерево.
parent(alexei, tolia).
parent(alexei, volodia).
parent(tolia, tima).

Основной предикат.
answer(L, R) :- 
    query(L, Tree),
    process_tree(Tree, R).

Предикат обработки полученного дерева.
process_tree(accept(person(P1),relation(Rel),person(P2)), yes) :- 
    call(Rel, P1, P2), !.

process_tree(accept(X,Y,Z), no).

process_tree(find(question(Q), relation(Rel), person(P)),R) :-
    call(Rel, P, R).

Предикат, проверяющий родство в генеалогическом дереве. Данный предикат вызывается напрямую в предикате обработки дерева через метапредикат call.
brat(X,Y) :-
    parent(P,X), parent(P,Y), X \= Y.

Построение дерева выражения.
query(L, R) :- query(R,L,[]).

query(accept(Person1,Relation,Person2)) -->
    person(Person1, []), relation(Relation), person(Person2, [i]), ['?'].

query(find(Question,Relation,Person)) -->
    question(Question), {Question = question(chei)}, relation(Relation), person(Person, []), ['?'].

query(find(Question,Relation,Person)) -->
    question(Question), {Question = question(chei)}, person(Person, [i,n]), relation(Relation), ['?'].

Проверка на то, состоит ли атом, унифицированный с Form из некоторого префикса атома Word и символов, находящихся в списке Suffix.
is_form(Form, Word, Suffix) :- 
    atom_chars(Form, Fc), atom_chars(Word, Wc),
    append(FormPrefix, Suffix, Fc),
    append(WordPrefix, _, Wc),
    FormPrefix = WordPrefix.

question(question(Q)) --> {member(Q, [chei, kto])}, [Q].
relation(relation(R)) --> {member(R, [brat])}, [R].

person(person(X), Suffix) --> [P], {findall(X,parent(X,_), L1), findall(X, parent(_,X), L2), append(L1, L2, LT), sort(LT, L), member(X,L), is_form(P,X,Suffix)}.



## Результаты

?- answer([volodia,brat,toli,'?'],X).
X=yes;
false.

?- answer([kto,tolin,brat,'?'],X).
X=volodia;
false.

?- answer([chei,brat,volodia,'?'],X).
X=tolia;
false.

## Выводы

Данная работа показалось самой объемной и сложной. Она помогла мне научиться использовать DCG грамматику и совершать разбор естественного языкового выражения. Также я узнал, что логические языки отлично подходят для решения задач ИИ и подобных задач по разбору выражений.