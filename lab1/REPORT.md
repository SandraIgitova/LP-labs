# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Семенов И.М.

## Результат проверки

| Преподаватель | Дата | Оценка |
|-------------------|--------------|---------------|
| Сошников Д.В. | | |
| Левинская М.А.| | |

## Введение

В языках программирования, относящихся к императивной парадигме, для хранения последовательности некоторых объектов обычно(в самом общем) случае используют массивы. Также, в императивных языках имеется необходимый инструментарий для создания более сложных и специфичных структур для хранения данных - списков(однонаправленных или двунаправленных), динамических массивов(векторов), очередей, стеков, разнообразных деревьев, хэш-таблиц и так далее. Обычно, реализации большего количества из вышеперечисленных структур входят в стандартную библиотеку языка. В языке программирования Prolog для хранения коллекции объектов предусмотрена встроенная стуктура - список. Структура списка определяется рекурсивно: список либо является пустым, либо состоит из первого элемента(головы) и хвоста-остатка, являющегося списком. Списки в Prolog реализуются с помощью встроенного функтора ".", который соединяет голову и хвост списка. Также стоит упомянуть, что в списке могут хранится любые объекты, даже другие списки. При обработке списков(которая в Prolog осуществляется рекурсивно) часто используется операция расщепления на голову и хвост, представленная символом вертикальной черты.


## Задание 1.1: Предикат обработки списка
Принадлежность элемента к списку

?- l_member(1,[1,2,3]).
true.
?- l_member(4,[1,2,3]).
false.
?- l_member(X, [1,2,3]).
X = 1 ;
X = 2 ;
X = 3.

l_member(X,[X|T]).
l_member(X,[H|T]):-member(X,T).

Подсчет длины списка

?- l_length([1,2,3,4],X).
X = 4.

l_length([], 0).
l_length([X|Y], S) :- 
    l_length(Y, S1), S is S1 + 1.

Удаление элемента из списка

?- l_remove(2,[1,2,3,4], X).
X = [1,3,4].

l_remove(X,[X|T],T).
l_remove(X,[H|T],[H|R]):-l_remove(X,T,R).

Конкатенация двух списков

?- l_append([1,2,3], [4,5,6], X).
X = [1, 2, 3, 4, 5, 6].

?- l_append(X, [4,5,6], [1,2,4,5,6]).
X = [1, 2] ;
false.

l_append([],L,L).
l_append([X|T],L,[X|L1]):-append(T,L,L1).

Проверка на то, является ли один список подсписком другого
В различных версиях Prolog данный предикат реализован по-разному, не всегда предполагается, что элементы первого списка во втором должны идти подряд.

?- l_sublist([1,2], [1,3,2,4]).
true .

?- l_continious_sublist([1,2], [1,3,2,4]).
false.

?- l_continious_sublist([1,2], [1,3,2,1,2,4]).
true .

l_continious_sublist(R,L):-append(_,K,L),append(R,_,K).

l_sublist(Sub, List) :-
	l_sublist_(List, Sub).

l_sublist_([], []).
l_sublist_([H|T], Sub) :-
	l_sublist__(T, H, Sub).

l_sublist__([], H, [H]).
l_sublist__([], _, []).
l_sublist__([H|T], X, [X|Sub]) :-
	l_sublist__(T, H, Sub).
l_sublist__([H|T], _, Sub) :-
	l_sublist__(T, H, Sub).

Перестановочный предикат

?- l_permute([X,Y,Z], [1,2,3]).
X = 1,
Y = 2,
Z = 3 ;
X = 1,
Y = 3,
Z = 2 ;
X = 2,
Y = 1,
Z = 3 ;
X = 3,
Y = 1,
Z = 2 ;
X = 2,
Y = 3,
Z = 1 ;
X = 3,
Y = 2,
Z = 1 ;
false.

l_permute([],[]).
l_permute(L,[X|T]):- l_remove(X,L,R), l_permute(R,T).

## Задание 1.1: Предикат обработки списка

Предикат, удаляющий последний элемент списка

?- l_remove_last([1,2,3,4], X).
X = [1,2,3].

l_remove_last([X|[]], []) :- !.
l_remove_last([X|T], R) :- 
    l_remove_last(T, R1), R = [X|R1].

l_remove_last2([X|[]], []) :- !.
l_remove_last2([X|T], R) :- 
    l_remove_last2(T, R1), append([X], R1, R).

Результатом работы для списка из одного элемента является пустой список.
Результатом работы для списка из множества элементов является конкатенация первого элемента списка и результата работы данного предиката для его хвоста.   


## Задание 1.2: Предикат обработки числового списка

Предикат, подсчитывающий количество четных элементов в списке

?- l_count_even([1,3,5,7], X).
X = 0.
?- l_count_even([2,4,6,8], X).
X = 4.

l_count_even([], 0) :- !.
l_count_even([X|T], R) :-
	X mod 2 =:= 0, l_count_even(T, R1), R is R1 + 1, !.
l_count_even([X|T], R) :-
	X mod 2 =\= 0, l_count_even(T, R), !.

l_count_even2([], 0) :- !.
l_count_even2([X|T], R) :-
	X mod 2 =:= 0, remove(X,[X|T],T1), l_count_even(T1, R1), R is R1 + 1, !.
l_count_even2([X|T], R) :-
	X mod 2 =\= 0, remove(X,[X|T],T1), l_count_even(T1, R),!.

Результат работы от пустого списка - 0.
Результатом работы от непустого списка является результат работы от хвоста списка, увеличенный на 1 при том условии, что голова списка четная.

## Задание 2: Реляционное представление данных

Реляционное представление - представление, основанное на отношениях между объектами, такое представление также часто называют табличным. При запросе к реляционной структуре, ответом является некоторое множество объектов. Такая модель отображает данные в достаточно простой и понятной форме. С данными в реляционном представлении удобно работать, используя логические и функциональные языки программирования. 

В моем варианте представления(one.pl) отношения представлены таким образом:
student(102,'Петров').
subject('LP','Логическое программирование').
grade('Петров','LP',4).

Для данного представления я выбрал следующее задание:

Вариант 3
- Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
- Для каждого предмета, найти количество не сдавших студентов
- Для каждой группы, найти студента (студентов) с максимальным средним баллом


Подзадача 1 - Для каждого студента, найти средний балл, и сдал ли он экзамены или нет

Основной предикат, осуществляющий обработку, использует findall для получения списка всех студентов.
task1() :- 
    findall(X, student(_, X), StudentsList),
    get_average_grade(StudentsList, Grades, Passed),
    print_average_grade(StudentsList, Grades),
    print_pass(StudentsList, Passed).

Получает на вход список студентов и с помощью предиката findall и дальнейшего рекурсивного вызова самого себя составляет список из их средних оценок и список из значений true/false, который позволяет понять, сдали они экзамены или нет.
get_average_grade([], [], []) :- !.
get_average_grade([X|T], RG, RP) :- 
    findall(Grade, grade(X,_,Grade), Grades),
    get_list_sum(Grades, Sum),
    check_for_pass(Grades, Pass),
    length(Grades, Length),
    Average is Sum / Length,
    get_average_grade(T, R1, R2),
    append([Average], R1, RG),
    append([Pass], R2, RP).

Этот и следующий предикат используются исключительно для вывода списков, полученных в результате работы предикатов выше, в нужном формате.
print_average_grade([],[]).
print_average_grade([S|ST],[G|GT]) :- 
    write("Student "), write(S), write(" has average grade "),write(G), nl,
    print_average_grade(ST, GT).

print_pass([],[]).
print_pass([S|ST], [P|PT]) :- 
    P = true, 
    write("Student "), write(S), write(" passed the exams"), nl,
    print_pass(ST, PT).
print_pass([S|ST], [P|PT]) :- 
    P = false, 
    write("Student "), write(S), write(" not passed the exams"), nl,
    print_pass(ST, PT).

Предикат, позволяющий получить сумму элементов целочисленного списка.
get_list_sum([], 0).
get_list_sum([X|T], R) :-
    get_list_sum(T, R1), R is R1 + X.

Проверяет, сдал ли некий студент экзамены, по списку его оценок. Если среди них находится хотя бы одна двойка, то во второй аргумент помещается false, иначе туда помещается true.
check_for_pass([], true).
check_for_pass([X|XT], R) :-
    X =< 2, R = false.
check_for_pass([X|XT], R) :-
    X >= 3, check_for_pass(XT, R).

Подзадача 2 - Для каждого предмета, найти количество не сдавших студентов

Основной предикат, сначала находит список всех предметов, используя findall, далее вызывает предикат, подсчитывающий количество несдавших студентов.
task2() :- 
    findall(X, subject(X,_), Subjects),
    count_failed_students(Subjects, Failed),
    print_failed(Subjects, Failed).

Принимает список предметов, возвращает список целых чисел, являющихся количеством студентов, сдавших данный предмет на оценку 2.
count_failed_students([], []).
count_failed_students([Subj|SubjT], R) :-
    findall(X, grade(X, Subj, 2), FailedList),
    length(FailedList,CurCount),
    count_failed_students(SubjT, Count),
    append([CurCount], Count, R).

Предикат, использующийся для вывода результата.
print_failed([],[]).
print_failed([S|ST], [C|CT]) :-
    subject(S, TextSubject),
    write("Count of students failed "), write(TextSubject), write(" is "), write(C), nl,
    print_failed(ST, CT).

Подзадача 3 - Для каждой группы, найти студента (студентов) с максимальным средним баллом.

Основной предикат, сначала получает список групп, далее сортирует его и удаляет из него дубликаты, получает для каждой группы список студентов с максимальным средним баллом и выводит его.
task3() :- 
    findall(X, student(X,_), BadGroups),
    sort(BadGroups, Groups),
    find_students_in_group(Groups, ListOfStudents),
    print_students_in_group(Groups, ListOfStudents).

Принимает список групп, ищет всех студентов данной группы с помощью предиката findall, получает среднюю оценку для каждого из них, используя предикат из подзадачи 1, далее формируется список лучших студентов группы и включается в результат. Предикат вызывается рекурсивно, обрабатывая новую группу при каждом вызове.
find_students_in_group([], []).
find_students_in_group([G|GT], R) :-
    findall(X, student(G, X), Students),
    get_average_grade(Students, Grades, _),
    get_students_with_max_grade(Students, Grades, _ , List),
    find_students_in_group(GT, R1),
    R = [List|R1].

Предикат для получения списка студентов с максимальным средним баллом, принимает список студентов и список их средних баллов.
get_students_with_max_grade([],[], 0, []).
get_students_with_max_grade([St|StT],[Gr|GrT], MaxGrade, R) :-
    get_students_with_max_grade(StT, GrT, OldGrade, R1),
    OldGrade > Gr,
    MaxGrade is OldGrade,
    R = R1.

get_students_with_max_grade([St|StT],[Gr|GrT], MaxGrade, R) :-
    get_students_with_max_grade(StT, GrT, OldGrade, R1),
    OldGrade =:= Gr,
    MaxGrade is OldGrade,
    append([St], R1, R).

get_students_with_max_grade([St|StT],[Gr|GrT], MaxGrade, R) :-
    get_students_with_max_grade(StT, GrT, OldGrade, R1),
    OldGrade < Gr,
    MaxGrade is Gr,
    R = [St].

Предикат для вывода полученного результата.
print_students_in_group([], []).
print_students_in_group([Gr|GrT], [Sts|StsT]) :- 
    length(Sts, 1),
    write("Best students in group "), write(Gr), write(" is "), write(Sts), nl,
    print_students_in_group(GrT,StsT).
print_students_in_group([Gr|GrT], [Sts|StsT]) :- 
    not(length(Sts, 1)),
    write("Best students in group "), write(Gr), write(" are "), write(Sts), nl,
    print_students_in_group(GrT,StsT).

## Выводы

Данная работа не является моим первым опытом работы с языком Prolog(ранее я реализовал на этом языке парсер для формата .ged). Тем не менее, выполнив лабораторную работу я стал лучше понимать принципы написания программ на языке Prolog и ознакомился со многими его встроенными предикатами. В процессе реализации своих предикатов, я лучше понял, как работает рекурсия, являющаяся основным инструментом написания программ почти любого языка программирования, не являющегося императивным. Также я познакомился с трассировкой программ. Хотя мне почти не пришлось ей пользоваться, я узнал, что это довольно мощное средство для отладки своих программ. Благодаря данной работе я стал лучше понимать парадигму логического программирования и узнал для себя много нового.